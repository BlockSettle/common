syntax = "proto2";

package Blocksettle.Communication;

enum RequestType
{
   SubmitAuthAddressForVerificationType = 1;
   GetBSFundingAddressListType          = 2;
   ErrorMessageResponseType             = 3;
   GetCCGenesisAddressesType            = 5;
   SubmitCCAddrInitialDistribType       = 6;
   GenerateCCSeedRequestType            = 7;
   RevokeAuthAddressRequestType         = 8;
   ConfirmAuthAddressSubmitType         = 9;
   CancelAuthAddressSubmitType          = 10;
   FundCCGenAddrRequestType		= 11;
   GetNetworkSettingsType               = 12;
}

enum AddressNetworkType
{
   MainNetType = 1;
   TestNetType = 2;
}

enum AddressScriptType
{
   PayToHashScriptType = 1;
   NestedSegWitScriptType = 2;
   NativeSegWitScriptType = 3;
}

// type of address used for verifications ( bitcoin, colored coin etc)
enum AddressType
{
   BitcoinsAddressType        = 1;
}

// copy of autheid.rp.GetResultResponse.SignatureResult
message AuthEidSign
{
   enum Serialization
   {
      JSON = 0;
      PROTOBUF = 1;
   }

   required Serialization serialization = 1;

   // Serialized autheid::rp::SignatureData message.
   // We should pass it as is to be able verify signature.
   // invisible_data field is SHA256 hash of requestData.
   required bytes signature_data = 2;

   required bytes sign = 3;

   // Certificate used for sign verification
   required bytes certificate_client = 6;

   required bytes certificate_issuer = 7;

   required bytes ocsp_response = 8;
}

message RequestPacket
{
   // requestType - hint to requestData type
   required RequestType requestType = 1;
   required bytes       requestData = 2;
   optional bytes       unsignedMixIn = 4;
   optional AuthEidSign authEidSign = 5;
}

message ResponsePacket
{
   required RequestType responseType = 1;
   required bytes       responseData = 2;
   optional bytes       dataSignature = 3;
}

message SubmitAuthAddressForVerificationRequest
{
   required AddressType          addressType = 2;
   required AddressNetworkType   networkType = 3;
   required AddressScriptType    scriptType = 4;
   required bytes                address160hex = 5;
   required string               userName = 8;
}

message GetBSFundingAddressListRequest
{
   required AddressType       addressListType = 1;
}

message GetBSFundingAddressListResponse
{
   required AddressType       addressListType         = 1;
   // for now it will be always of type AddressList.
   // use bytes just to simplify signature verification
   repeated bytes             addressList             = 2;
}

message SubmitAuthAddressForVerificationResponse
{
   required bool                 keySubmitted = 1;
   optional AddressNetworkType   networkType = 2;
   optional AddressScriptType    scriptType = 3;
   required bytes                address160hex = 4;
   optional string               errorMessage = 6;
   optional bool                 requestConfirmation = 7;
   optional float 		         validationAmount = 8;
}

message ErrorMessageResponse
{
   required string errorMessage = 1;
}

message ClientAddress
{
   required string fullName = 1;
   optional string address1 = 2;
   optional string address2 = 3;
   optional string postcode = 4;
   optional string state = 5;
   optional string city = 6;
   optional string country = 7;
   optional string mainPhone = 8;
   optional string company = 9;
   optional string countryCode = 10;
}

message GetCCGenesisAddressesRequest
{
   required AddressNetworkType   networkType = 1;
   optional int32                hasRevision = 2;
}

message GetCCGenesisAddressesResponse
{
   required AddressNetworkType   networkType  = 1;
   required int32                revision     = 2;
   repeated CCSecurityDefinition ccSecurities = 3;

   message CCSecurityDefinition {
      required string securityId  = 1;
      required string product     = 2;
      required bytes  genesisAddr = 3;
      required uint64 satoshisNb  = 4;
      optional string description = 5;
   }
}

message SubmitAddrForInitialDistributionRequest
{
   required AddressNetworkType   networkType     = 1;
   required bytes                prefixedAddress = 2;
   required uint32               bsSeed          = 3;
   required string               userName        = 4;
}

message SubmitAddrForInitialDistributionResponse
{
   required bool                 success         = 1;
   required bytes                prefixedAddress = 2;
   optional string               errorMessage    = 3;
}

message GenerateCCSeedRequest
{
   required string userName = 1;
   required string ccProduct = 2;
   optional double amount = 3;
   optional uint32 lotSize = 4;
}

message CCSeedResponse
{
   required uint32 bsSeed = 1;
   required string ccProduct = 2;
}

message RevokeAuthAddressRequest
{
   required string authAddress = 1;
}


message ConfirmAuthSubmitRequest
{
   required string userName = 1;
   required string address = 2;
   required AddressNetworkType networkType = 3;
   required AddressScriptType  scriptType = 4;
   required string userId = 6;
}

message ConfirmAuthSubmitResponse
{
   required string address = 1;
   optional string errorMsg = 2;
}

message CancelAuthAddressSubmitRequest
{
   required string userName = 1;
   required string address  = 2;
   required string userId   = 3;
}

message CancelAuthAddressSubmitResponse
{
   required string address = 1;
   optional string errorMsg = 2;
}

message FundCCGenAddrRequest
{
   required string   cc_product = 1;
   required uint32   amount = 2;
   required uint32   lot_size = 3;
   optional string   reference = 4;
}


message GetNetworkSettingsResponse
{
   message ConnectionData
   {
      required string host = 1;
      required uint32 port = 2;
   }

   optional ConnectionData celer = 1;
   optional ConnectionData marketData = 2;
   optional ConnectionData mdhs = 3;
   optional ConnectionData chat = 4;
   optional ConnectionData proxy = 5;
}
